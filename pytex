
# Copyright 2015-2017, 2019-2022
# Laurent Claessens
# contact : laurent@claessens-donadello.eu

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# https://github.com/LaurentClaessens/pytex

import os
import sys
import subprocess

from src.utilities import logging
from src.options import Options
from src.future_verif import get_future_warning
from src.all import FileToText
from src.all import FileToLatexCode
from src.all import FileToLogCode
from src.all import string_to_latex_code
from src.PytexTools import Compilation
from src.grep_wrapper import PytexGrep


dprint = print


"""
Note 25637 : THE PLUGIN TYPES

* 'options' :
    applied to the Options itself, it is applied after the import
* 'before_pytex' :
    applied on the text (as sting) before to create the pytex file.
* 'after_pytex' :
    applied on the LaTeXCode of the pytex file.
* 'before_compilation' :
    applied on nothing, before the compilation.
    Such a plugin does not return anything. It is devoted to perform
    some checks before to compile.
    Example : check that a file exist before to compile,
    or write a greeting to the user.

* 'after_compilation' :
    applied on nothing, after the compilation.
    Such a plugin does not return anything. It is devoted to
    perform some checks after compilation.
    Example : check that a file has been created or make
    some research in the auxiliary files.

Options :
    --no-compilation
        Do not compile, but produce the final _pytex.tex file and
        print the commands that were to be launched without.
    --rough-source
        Output an extremely hard-coded pytex file which is
        ready for ArXiv.

    --output=<filame>
        Output the summary informations in <filename>.
        This does not empties the file if it exists,
        but creates it if it does not exist.

"""


#       La couleur dans laquelle sont écrits les textes.
ColTexte = 33
# C'est peut-être encore un peu tricher
utilisateur = subprocess.getoutput("whoami")
HOME = subprocess.getoutput("echo $HOME")
PYTHONPATH = subprocess.getoutput("echo $PYTHONPATH")


class FileOutput(object):
    """
    A `FileOutput` object is intended to be given as `out` in
    `SummaryOutput`. Thus here the write` function always gets
    a single `str` argument, since the work of conversion from `*args` is
    done in `SummaryOutput.__call__`

    Creating an object does not empties the log file. The reasons is that
    one round of testing a document asks for several launch of `pytex`. Only
    the output of the last one would be available in the log file.

    However, here we check that the file exists; if not we create it.
    """

    def __init__(self, filename):
        self.filename = filename
        if not os.path.isfile(self.filename):
            with open(self.filename, 'w') as f:
                f.write("Here is the log file")

    def write(self, text):
        sys.stdout.write(text)
        with open(self.filename, 'a') as f:
            f.write(text)


def arg_to_output(arg):
    """
    from a string of the form
    'output=<filename>'
    creates an output that prints on the screen and in the file.
    """
    filename = arg.split("=")[1]
    return SummaryOutput(FileOutput(filename))


def ecrire(texte, couleur, output=None):
    # Noir 30 40, Rouge 31 41, Vert 32 42, Jaune 33 43, Bleu 34 44,
    # Magenta 35 45, Cyan 36 46, Blanc 37 47,
    # la police: 0->rien,  1->gras, 4->souligné, 5->clignotant, 7->inversée
    string = "\033[0;"+str(couleur)+";33m"+texte+"\033[0;47;33m"
    if output is None:
        print(string)
    else:
        output(string)





def set_no_useexternal(A):
    r"""
    This plugin is automatically applied when 'pytex' is invoked with
    '--no-external'. You have to put something like this before
    '\begin{document}' :


    \newcounter{useexternal}
    \setcounter{useexternal}{1}
    \ifthenelse{\value{useexternal}=1}
            { \usetikzlibrary{external} \tikzexternalize }
            { \newcommand{\tikzsetnextfilename}[1]{} }

    This plugin will change the '1' into '0', in such a way that
    'external' will not be used.

    See position 2764113936
    """
    u = r"""\setcounter{useexternal}{1}"""
    A = A.replace(u, u.replace("1", "0"))
    return A


def randombase(n=6):
    """
    return a random string of (by default) 6 characters.
    """
    import random
    import string
    rb = ""
    for i in range(0, n):
        rb = rb+random.choice(string.ascii_letters)
    return rb



def verif_grep(options):
    if options.nombre_prob > 1:
        options.output("Still "+str(options.nombre_prob) +
                       " problems to be fixed. Good luck !")
    if options.nombre_prob == 1:
        options.output(
            "Only one problem to be fixed. Next to perfection !!")
    x = FileToLogCode(options)
    options.output(x)


def ProduceIntermediateCode(options):
    codeLaTeX = string_to_latex_code(options.text_before_pytex)
    if options.Compil.tout == 0:
        list_input = codeLaTeX.search_use_of_macro("\input", 1)
        begin_document = codeLaTeX.find("\\begin{document}")
        for occurrence in list_input:
            A = occurrence.analyse()
            # If an "\input" is before "\begin{document}", we keep it.
            # This behaviour is due to the fact that some
            # "\input" are in the preamble,
            # inside \newcommand for example.
            if A.position > begin_document:
                if not options.accept_input(A.filename):
                    codeLaTeX = codeLaTeX.replace(occurrence.as_written, "%")
                else:
                    pass
    return codeLaTeX


def ProducePytexCode(options):
    """
    See the docstring of Options
    return an object LatexCode because it has to be passed to plugins.
    """
    # The plugin has to do itself the work to apply inputs if he wants to.
    # The reason is that some plugin just want to deal with the main tex file.
    codeLaTeX = options.intermediate_code()
    return codeLaTeX


def CreateRoughCode(options):
    """
    Creates a latex file that is ready to be send to Arxiv.

    See docstring of LatexCode.rough_source.
    """
    rough_code = options.rough_code(options)
    rough_code.save(options.source_filename)
    print("I created the source", options.source_filename)
    return options.source_filename


def RunMe(options):
    try:
        options.myRequest.run_prerequistes(options)
    except AttributeError:
        pass
    if options.Sortie.rough_source:
        options.create_rough_source(options.source_filename)

    if (options.Compil.verif == False)and(not options.Compil.lotex)and(options.Compil.simple == 1)and(options.Sortie.pdf == 0):
        options.compilation().latex_more(options)
        options.copy_final_file()

    if options.Compil.lotex:
        on = True
        while on:
            options.compilation().latex_more(options)
            options.copy_final_file()
            x = FileToLogCode(options, stop_on_first=True)
            on = x.rerun_to_get_cross_references(stop_on_first=True)
    if not options.Sortie.nocompilation and not options.Compil.verif:
        verif_grep(options)
    if options.Sortie.nocompilation:
        print("Le fichier qui ne fut pas compilé est", options.pytex_filename)
    else:
        print("Le fichier qui fut compilé est", options.pytex_filename)
        options.apply_plugin("", "after_compilation")
    if options.Compil.verif:
        options.future_reference_verification(options)

#############################
#
# Le début de l'exécution proprement dite
#
###############################


t = Options(sys.argv[1:])
output = t.output
RunMe(t)
