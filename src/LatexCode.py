###########################################################################
#   This is the package latexparser
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
###########################################################################

# copyright (c) Laurent Claessens, 2010,2012-2017, 2020
# email: laurent@claessens-donadello.eu

import codecs

from pytex.src.utilities import ensure_unicode
from pytex.src.utilities import RemoveComments
from pytex.src.InputPaths import InputPaths
from pytex.src.RoughSources import LatexCodeToRoughSource


def inherit_properties(f):
    """
    Decorator. A method of 'LatexCode' that is marked with this decorator
    will return 'LatexCode' object that inherits from the base object.
    """
    def g(code, *args):
        # Create the new code as the original function would do it
        new_code = f(code, *args)

        # Inherit the attributes
        new_code.input_paths = code.input_paths
        new_code.filename = code.filename
        new_code.included_file_list = code.included_file_list
        return new_code
    return g


class LatexCode(object):
    """
    Contains the informations about a LaTeX code.

    This class does not take track of the comments in the code. The symbol % is however kept because it
    is important for paragraphs in LaTeX.

    If your code is in a file, use the function FileToLatexCode:
    FileToLatexCode("MyFile.tex")
    returns a LatexCode instance.
    """
    # In a previous version, we were keeping the comments, but it caused some difficulties because, for example, we had to only perform the
    # replacements outside the comments, so that we had to perform replacements line by line. It was painfully slow.
    # If you have any idea how to keep track of the comments without slow down the process, please send a patch :)

    # However it is possible to keep the comments using 'keep_comments=True'.
    def __init__(self, given_text, filename=None, oldLaTeX=None, keep_comments=False):
        """
        self.text_brut          contains the tex code as given, with or without the comments, depending on 'keep_comments'

        If one create a codeLaTeX from an other, use derive_from by passing oldLaTeX to __init__
        """
        # If you change something here, it has to be changed in append_file.
        self.given_text = given_text
        if keep_comments:
            self.text_brut = ensure_unicode(self.given_text)
        else:
            self.text_brut = ensure_unicode(RemoveComments(self.given_text))
        self._dict_of_definition_macros = {}
        self._list_of_input_files = []
        self.filename = filename
        # When the code is created from files, the filename are recorded here.
        self.included_file_list = []
        if oldLaTeX:
            self.derive_from(oldLaTeX)
        self.input_paths = InputPaths()

    def derive_from(self, oldLaTeX):
        self.included_file_list = oldLaTeX.included_file_list

    def copy(self):
        """
        Return a copy of self in a new object

        The fact to copy properties here (like 'input_paths') is not really
        efficient because the majority of operations are replacements and
        are returning new objects.
        See for example
        RoughSources.LatexCodeToRoughSource
        Although 'new_code' is at the beginning a 'copy', we still have to update
        by hand the input_list.
        """
        A = LatexCode(self.text_brut)
        A.input_paths = self.input_paths
        return A

    def save(self, filename=None, preamble=True):
        """
        Save the code in a file.

        Optional <filename> provides a file name that overrides the self.filename. If none of filename and self.filename are give, an exception is raised.
        Optional preamble (boolean) : yes or no, do we add the preamble speaking about the scripts.

        """

        preamble = r"""% This file is automatically generated by some pre-compilation scripts.
%See
% https://github.com/LaurentClaessens/latexparser
% https://github.com/LaurentClaessens/phystricks
%Please contact the author at moky.math@gmail.com for asking original source file and scripts.
%
        """
        written_text = self.text_brut
        if preamble:
            written_text = preamble+written_text
        if filename:
            self.filename = filename
        else:
            filename = self.filename
        f = codecs.open(filename, "w", "utf_8")
        f.write(written_text)
        f.close()

    def get_newlabel_value(self, label_name):
        r"""
        Assumes that self is a .aux file. Return the value associated to the line \newlabel{<label_name>}

        It it appears many times, return the last time, and prints a warning.

        If not found, raise an newlabelNotFound exception
        """
        list_newlabel = self.analyse_use_of_macro("\\newlabel", 2)
        if label_name not in [x.name for x in list_newlabel]:
            raise newlabelNotFound(label_name)
        list_interesting = [x for x in list_newlabel if x.name == label_name]
        if len(list_interseting) > 1:
            print("Warning : label %s has %s different values" %
                  (label_name, str(len(list_interesting))))
        return list_interesting[-1].value

    def search_use_of_macro(self, name, number_of_arguments=None, give_configuration=False, fast=False):
        r"""
        Return a list of Occurrence of a given macro. You have to include the "\" in the name, for example
        codeLaTeX.search_use_of_macro("\MyMacro",2)
        is the good way to study the use of macro \MyMacro, provided that it has exactly 2 arguments.

        Optional argument: number_of_arguments=None
        If no occurrence are found, return an empty list.

        If give_configuration is True, return a tuple of two lists.
        - The first list is the same as with give_configuration=False
        - The second gives the text between the occurrences.

        The ith element of the configuration list is what precedes
        the ith element of the occurrence list.
        The configuration list has one more element.
        The following has to be true
        self.text_brut==configuration[0]+occurrence[0]+...+configuration[n]+occurrence[n]+configuration[n+1]
        """
        # Why should I explicitly write the "\" in the macro name ?
        # I don't remember, but it was an issue.
        from pytex.src.MacroUse import SearchUseOfMacro
        return SearchUseOfMacro(self, name, number_of_arguments, give_configuration, fast=fast)

    def analyse_use_of_macro(self, name, number_of_arguments=None):
        """
        Provide a list of analyse of the occurrences of a macro.

        Optional argument: number_of_arguments=None, to be passed to search_use_of_macro
        """
        return [occurrence.analyse() for occurrence in self.search_use_of_macro(name, number_of_arguments)]

    def macro_definition(self, name):
        return MacroDefinition(self, name)

    def statistics_of_the_macro(self, name):
        return StatisticsOfTheMacro(self, name)

    def dict_of_definition_macros(self):
        r"""
        Returns a dictionary which gives, for each name of macros found to be defined in self.text, the occurrence
        in which it was defined.
        If X is the output of dict_of_definition_macro, X.keys() is the list of the names of the macros and
        X.values() is the list of definition (type Occurrence_newcommand).

        The macro Foo is "defined" in the text when "Foo" comes as first argument of a definition command.
        (cf. the global variable definition_commands) Typically when
        \\newcommand{\Foo}[2]{bar}
        or
        \\renewcommand{\Foo}{bar}
        """
        if self._dict_of_definition_macros == {}:
            print("Je r√©invente la roue")
            dico = {}
            for definer in definition_commands:
                for occurrence in self.search_use_of_macro(definer, 3):
                    newcommand = Occurrence_newcommand(occurrence)
                    name = newcommand.name
                    if name in dico.keys():
                        print("%s was already defined !!" % name)
                    else:
                        dico[name] = newcommand
            self._dict_of_definition_macros = dico
        return self._dict_of_definition_macros

    def list_of_input_files(self):
        if self._list_of_input_files == []:
            list = []
            for occurrence in self.search_use_of_macro("\input", 1):
                list.append(occurrence.analyse().filename)
            self._list_of_input_files = list
        return self._list_of_input_files

    def substitute_occurrence_input(self, occurrence, substitution_text):
        """
        - `occurrence` is the occurrence of an \input{<filename>}.
        - `substitution_text` is the text with whom we have to
           substitute the occurrence of \input

        Replace the occurrence by the given substitution text

        This is not intrinsically recursive, but when we call this method,
        the recursion is already done.
        """
        if occurrence.filename.endswith("_thm"):
            # This is hard-coded for Giulietta
            print("Do not add", occurrence.filename)
            return LatexCode(self.text_brut)
        print("Adding file", occurrence.filename)
        A = LatexCode(self.text_brut)
        A.included_file_list = self.included_file_list
        A.included_file_list.append(occurrence.filename)
        A = A.replace(occurrence.as_written, substitution_text)
        return A

    def substitute_all_inputs(self, fast=False, input_paths=None):
        r"""
        Recursively change all the \input{...} by the content of the corresponding file.
        Return a new object LatexCode
        """
        A = LatexCode(self.text_brut)
        if input_paths is None:
            input_paths = InputPaths()

        # The \input macro search for the files in the directories
        # listed in \input@path. In mazhe I define the macro
        # \addInputPath in order to add a path in that list. We are here
        # searching for the occurrence of \addInputPath in the file to be
        # expanded, so that we know in which directory we have
        # to search for the files that are inputed.
        list_addInputPath =\
            [x.analyse() for x in
                A.search_use_of_macro(r"\addInputPath", 1, fast=fast)]
        for occ in list_addInputPath:
            input_paths.append(occ.directory)
        list_input = []
        for x in A.search_use_of_macro("\input", 1, fast=fast):
            y = x.analyse()
            y.input_paths = input_paths
            list_input.append(y)
        if list_input == []:
            return self
        new_code = LatexCode(self.text_brut)
        for occurrence in list_input:
            file_content = occurrence.file_content(input_paths)
            A = LatexCode(file_content)
            B = A.substitute_all_inputs(input_paths=input_paths)
            new_code = new_code.substitute_occurrence_input(
                occurrence, B.text_brut)
        new_code.input_paths = input_paths
        return new_code

    def change_macro_argument(self, macro_name, n, func, n_args):
        r"""
        Apply the function <func> to the <n>th argument
        of each use of <macro_name>.

        Return a new_object LatexCode
        """
        list_occurrences, configuration = self.search_use_of_macro(
            macro_name, n_args, give_configuration=True)
        a = ""
        for i in range(len(list_occurrences)):
            a = a+configuration[i] + \
                list_occurrences[i].change_argument(n, func).as_written
        a = a+configuration[-1]
        return LatexCode(a)

    def change_labels_refs(self, func):
        r"""
        Change \ref{MyLabel}, \eqref{MyLabel} and \label{MyLabel} applying func to the argument.
        """
        x = self.change_macro_argument(r"\ref", 1, func, 1)
        y = x.change_macro_argument(r"\eqref", 1, func, 1)
        z = y.change_macro_argument(r"\label", 1, func, 1)
        self.__init__(z.text_brut)

    def remove_macro_content(self, macro_name, number_of_arguments):
        r"""
        Remove the presence of a macro (not its definition).
        Example

        Hello \MyMacro{guy} how do you do ?

        will become
        Hello how do you do ?

        Return a new LatexCode object.
        """
        A = self.copy()
        liste_occurrences = A.search_use_of_macro(
            macro_name, number_of_arguments)
        for occurrence in liste_occurrences:
            A = A.replace(occurrence.as_written, "")
        return A

    def remove_macro_name(self, macro_name, number_of_arguments):
        r"""
        Remove the macro name, but leaves the argument.
        Example

        Hello \MyMacro{guy} how do you do ?

        will become
        Hello guy how do you do ?

        This function only works with a macro which has only one argument.
        """
        A = self.copy()
        liste_occurrences = A.search_use_of_macro(
            macro_name, number_of_arguments)
        for occurrence in liste_occurrences:
            A = A.replace(occurrence.as_written, occurrence.arguments[0])
        return A

    def position_to_line(self, position):
        """
        return the line (as string) which contains the given position.
        """
        a = self.text_brut[0:position].rindex("\n")
        b = self.text_brut.index("\n", position)
        return self.text_brut[a+1:b]

    def find(self, arg):
        return self.text_brut.find(arg)

    @inherit_properties
    def replace(self, textA, textB):
        """
        Replace textA by textB including in the comments
        """
        textA = ensure_unicode(textA)
        textB = ensure_unicode(textB)
        new_text = self.text_brut.replace(textA, textB)
        A = LatexCode(new_text, oldLaTeX=self)
        return A

    def splitlines(self):
        textA = self.text_brut
        return textA.splitlines()

    def append_file(self, filename=None, filenames=None):
        """
        Append the content of a file to the current LaTeX code. Return a new object.

        If filename is given, add only this file
        If filenames is given, add all the files.

        See the method __add__
        """
        if filename:
            if ".tex" not in filename:
                filename = filename+".tex"
            new = self+FileToLatexCode(filename)
            self.__init__(new.text_brut)
        if filenames:
            for i in range(len(filenames)):
                if ".tex" not in filenames[i]:
                    filenames[i] = filenames[i]+".tex"
            a = ""
            for f in filenames:
                a = a+FileToText(f)
            add_given_text = a
            self.__init__(self.given_text+add_given_text)

    def rough_source(self, filename, bibliography_bbl_filename=None, index_ind_filename=None, fast=False):
        """
        Return the name of a file where there is a rough latex
        code ready to be published to Arxiv
        """
        a = LatexCodeToRoughSource(
            self, filename, bibliography_bbl_filename, index_ind_filename, fast=fast)
        return a

    def __add__(self, other):
        new_given_text = self.given_text+other.given_text
        return LatexCode(new_given_text)
