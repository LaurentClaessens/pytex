"""Check the references to the future."""


from pytex.src.future_verif import get_future_warning
from pytex.src.LatexCode import LatexCode


def future_reference_verification(options, fast=True):
    r"""
    Print the list of references that are made to the future.

    If fast is true, make more assumptions on the LaTeX code.
    You will only catch references and label like
    \ref{foo}
    \label{bar}
    while not matching
    \ref
    {foo}
    or
    \label{foo\Macro{bar}boor}
    """

    # rough_code with fast=True is buggy.
    rough_code: LatexCode = options.rough_code(options, fast=False)
    rough_code.save("voir.tex")
    ciao()

    print("Analysing the document for label")
    labels = rough_code.search_use_of_macro("\label", 1, fast=fast)

    print("Analysing the document for ref")
    ref = rough_code.search_use_of_macro(r"\ref", 1, fast=fast)

    print("Analysing the document for eqref")
    eqref = rough_code.search_use_of_macro("\eqref", 1, fast=fast)

    ref_dict = {}
    label_dict = {}

    print("Working on future references ...")

    for occ in labels:
        label = occ.arguments[0]
        ref_dict[label] = []

    references = ref[:]
    references.extend(eqref)

    for occ in references:
        label = occ.arguments[0]
        ref_dict[label] = []

    for occ in references:
        label = occ.arguments[0]
        ref_dict[label].append(occ)

    for occ in labels:
        label = occ.arguments[0]
        if label in label_dict.keys():
            options.output(
                "The label <{0}> is used multiple times".format(label))
            options.output("Here is the last time I see that")
            options.output(occ.as_written)
            raise NameError
        label_dict[label] = occ

    # The future references are detected in 'rough_code'
    # which is a large latex code recursively generated by applying
    # all the \input.
    # Let us say we found the line
    # "From the Stone theorem \ref{tho_stone} we deduce that blabla"
    # This line belongs to 'rough_source'
    # In order to provide the user with an useful information we have
    # to find back the line in the original sources.
    # That is grepping the line in the real sources.

    # For each future references, there are two concerned files
    # (maybe the same) :
    # the one in which we found the \(eq)ref and the one in which
    # is the corresponding \label. The 'concerned_files' list keeps is list
    # of the files that are concerned by a future references.
    future_warnings = []
    for tested_label in label_dict.keys():
        for ref in ref_dict[tested_label]:
            warning = get_future_warning(rough_code, label_dict,
                                         tested_label, ref,
                                         options.my_request)
            if warning:
                future_warnings.append(warning)

    concerned_files = set()
    total_futur = 0
    hexdigests = []
    for warning in future_warnings:
        # The function `has_to_be_printed` is defined in
        # the file `lst_foo.py`.
        if options.my_request.has_to_be_printed(warning):
            warning.output()
            hexdigests.append(warning.hexdigest)
            total_futur += 1
            for futur_file in warning.concerned_files:
                concerned_files.add(futur_file)

    print("All the wrong hashes:")
    for hexdigest in hexdigests:
        print(hexdigest)
    print(f"Number of future references: {total_futur}")
    print("concernd files:")
    for futur_file in concerned_files:
        print(futur_file)
